/**
 * @file main.cpp
 * @brief Closed-loop motor controller for a MÃ¤rklin motor using BEMF feedback.
 *
 * This firmware implements a closed-loop speed control system for a DC motor
 * using a XIAO RP2040 and a BDR-6133 H-bridge driver. Speed is measured by
 * counting back-EMF (BEMF) commutation pulses. A proportional controller
 * adjusts the motor power. The PWM signal is generated by a non-blocking,
 * interrupt-driven software implementation using two hardware timers to manage
 * the ON and OFF phases of the PWM cycle. This ensures consistent timing
 * without blocking in an ISR or the main loop.
 */
#include <Arduino.h>
#include <pico/time.h>

//== Pin Definitions ==
const int pwmAPin = D7;      ///< Pin for PWM Forward direction (connects to InA).
const int pwmBPin = D8;      ///< Pin for PWM Reverse direction (connects to InB).
const int bemfAPin = A3;     ///< ADC pin for BEMF measurement from motor terminal A.
const int bemfBPin = A2;     ///< ADC pin for BEMF measurement from motor terminal B.
const int statusLedPin = LED_BUILTIN; ///< Built-in LED for status indication.

//== Motor Control Parameters ==
const int max_speed = 255;  ///< Maximum target speed value, corresponds to max PWM duty cycle.
const int pwm_frequency = 1000; ///< PWM frequency in Hz.
const long pwm_period_us = 1000000 / pwm_frequency;
const long bemf_read_delay_us = 100; ///< uS to wait after coasting before BEMF read.

//== Proportional Controller ==
const float Kp = 0.1;       ///< Proportional gain for the P-controller.

//== BEMF Pulse Counting ==
const int bemf_threshold = 500; ///< ADC value threshold for detecting a commutation pulse.
volatile int commutation_pulse_count = 0; ///< Counter for BEMF pulses.
float measured_speed_pps = 0.0; ///< Calculated motor speed in pulses per second.
bool last_bemf_state = false;   ///< State of the BEMF signal in the previous cycle.

//== State Machine for Test Pattern ==
enum MotorState { RAMP_UP, COAST_HIGH, RAMP_DOWN, COAST_LOW, STOP };
MotorState current_state = RAMP_UP;
unsigned long state_start_ms = 0;
unsigned long last_ramp_update_ms = 0;
const int ramp_step_delay_ms = 20;

//== Global Motor & PWM State Variables ==
volatile int target_speed = 0;
volatile int current_pwm = 0;
volatile bool forward = true;
repeating_timer_t pwm_period_timer;

// Forward declarations for timer callbacks
bool pwm_period_callback(struct repeating_timer *t);
int64_t pwm_off_callback(alarm_id_t id, void *user_data);

/**
 * @brief Measures BEMF, counts pulses, and runs the P-controller.
 */
void update_motor_feedback() {
    int measured_speed = map(measured_speed_pps, 0, 500, 0, 255);
    int error = target_speed - measured_speed;
    noInterrupts();
    current_pwm = constrain(target_speed + (Kp * error), 0, max_speed);
    interrupts();
}

/**
 * @brief The second part of the PWM cycle (OFF phase).
 *
 * This function is scheduled as a one-shot alarm by the period callback.
 * It coasts the motor, waits for stabilization, and reads the BEMF.
 */
int64_t pwm_off_callback(alarm_id_t id, void *user_data) {
    // 1. Put H-Bridge into high-impedance state
    pinMode(pwmAPin, INPUT);
    pinMode(pwmBPin, INPUT);
    // 2. Wait for voltage to stabilize
    delayMicroseconds(bemf_read_delay_us);

    // 3. Perform differential BEMF measurement
    int bemfA = analogRead(bemfAPin);
    int bemfB = analogRead(bemfBPin);
    int measured_bemf = abs(bemfA - bemfB);

    // 4. Detect rising edge of a commutation pulse
    bool current_bemf_state = (measured_bemf > bemf_threshold);
    noInterrupts();
    if (current_bemf_state && !last_bemf_state) {
        commutation_pulse_count++;
    }
    last_bemf_state = current_bemf_state;
    interrupts();

    return 0; // Don't re-schedule
}

/**
 * @brief The first part of the PWM cycle (ON phase).
 *
 * This is called by a repeating timer at the PWM frequency. It starts the
 * motor drive and schedules the off-phase callback.
 */
bool pwm_period_callback(struct repeating_timer *t) {
    long on_time_us = map(current_pwm, 0, 255, 0, pwm_period_us);

    // Ensure there's enough time for the BEMF reading phase
    if (on_time_us > pwm_period_us - bemf_read_delay_us - 50) {
        on_time_us = pwm_period_us - bemf_read_delay_us - 50;
    }

    if (on_time_us > 0) {
        // --- ON Portion: Drive the motor ---
        pinMode(pwmAPin, OUTPUT);
        pinMode(pwmBPin, OUTPUT);
        if (forward) {
            digitalWrite(pwmAPin, HIGH);
            digitalWrite(pwmBPin, LOW);
        } else {
            digitalWrite(pwmAPin, LOW);
            digitalWrite(pwmBPin, HIGH);
        }
    } else {
        // If PWM is 0, just go straight to high-impedance
        pinMode(pwmAPin, INPUT);
        pinMode(pwmBPin, INPUT);
    }

    // Schedule the OFF-phase callback
    add_alarm_in_us(on_time_us, pwm_off_callback, NULL, true);

    return true; // Continue the repeating timer
}

/**
 * @brief Initializes hardware pins, serial, and the PWM timer.
 */
void setup() {
    pinMode(pwmAPin, OUTPUT);
    pinMode(pwmBPin, OUTPUT);
    pinMode(bemfAPin, INPUT);
    pinMode(bemfBPin, INPUT);
    pinMode(statusLedPin, OUTPUT);
    Serial.begin(9600);

    // Start the hardware timer for the PWM period
    add_repeating_timer_us(-pwm_period_us, pwm_period_callback, NULL, &pwm_period_timer);
}

void update_status_light() {
    unsigned long current_millis = millis();
    switch (current_state) {
        case RAMP_UP: case COAST_HIGH: case COAST_LOW:
            digitalWrite(statusLedPin, HIGH); break;
        case RAMP_DOWN:
            digitalWrite(statusLedPin, (current_millis / 500) % 2); break;
        case STOP:
            digitalWrite(statusLedPin, (current_millis / 100) % 2); break;
        default:
            digitalWrite(statusLedPin, LOW); break;
    }
}

void loop() {
    update_status_light();
    unsigned long current_millis = millis();

    static unsigned long last_speed_calc_ms = 0;
    if (current_millis - last_speed_calc_ms >= 100) {
        noInterrupts();
        int pulses = commutation_pulse_count;
        commutation_pulse_count = 0;
        interrupts();

        float elapsed_time_s = (current_millis - last_speed_calc_ms) / 1000.0;
        measured_speed_pps = pulses / elapsed_time_s;
        last_speed_calc_ms = current_millis;

        // Update P-controller with new speed measurement
        update_motor_feedback();
    }

    unsigned long time_in_state = current_millis - state_start_ms;
    switch (current_state) {
        case RAMP_UP:
            if (current_millis - last_ramp_update_ms >= ramp_step_delay_ms) {
                last_ramp_update_ms = current_millis;
                if (target_speed < max_speed) target_speed++;
                else { current_state = COAST_HIGH; state_start_ms = current_millis; }
            }
            break;
        case COAST_HIGH:
            if (time_in_state >= 3000) { current_state = RAMP_DOWN; state_start_ms = current_millis; }
            break;
        case RAMP_DOWN:
            if (current_millis - last_ramp_update_ms >= ramp_step_delay_ms) {
                last_ramp_update_ms = current_millis;
                if (target_speed > max_speed * 0.1) target_speed--;
                else { current_state = COAST_LOW; state_start_ms = current_millis; }
            }
            break;
        case COAST_LOW:
            if (time_in_state >= 3000) { current_state = STOP; state_start_ms = current_millis; target_speed = 0; }
            break;
        case STOP:
            if (time_in_state >= 2000) { forward = !forward; current_state = RAMP_UP; state_start_ms = current_millis; }
            break;
    }
}
